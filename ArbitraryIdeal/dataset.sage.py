

# This file was *autogenerated* from the file Documents/Math/AI-Experiments/GroebnerTime/ArbitraryIdeal/dataset.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_1000 = Integer(1000); _sage_const_10 = Integer(10); _sage_const_7 = Integer(7)
import random as rand
import multiprocessing as mp
from sage.rings.polynomial.toy_buchberger import *
import time

n = _sage_const_3 
var(['x' + str(i) for i in range(n)])

def gb_stopwatch(F, op_limit):
    G = set(F.gens())
    B = set((g1, g2) for g1 in G for g2 in G if g1 != g2)

    divisions = _sage_const_0 

    while divisions < op_limit and B:
        g1, g2 = select(B)
        B.remove((g1, g2))

        h = spol(g1, g2).reduce(G)
        if h != _sage_const_0 :
            B = B.union((g, h) for g in G)
            G.add(h)
            divisions += _sage_const_1 

        if h == _sage_const_0 :
            divisions += _sage_const_1 

    return divisions

def gen_dataset(OP_LIMIT, NUM_IDEALS, ORDERING, MAX_IDEAL_SIZE, MAX_POLY_TERMS,
                MIN_COEF, MAX_COEF, MAX_DEG):
    if ORDERING == _sage_const_0 :
        R = PolynomialRing(QQ, 'x', n, order='lex')
    elif ORDERING == _sage_const_1 :
        R = PolynomialRing(QQ, 'x', n, order='degrevlex')
    elif ORDERING == _sage_const_2 :
        R = PolynomialRing(QQ, 'x', n, order='deglex')
    elif ORDERING == _sage_const_3 :
        R = PolynomialRing(QQ, 'x', n, order='neglex')
    elif ORDERING == _sage_const_4 :
        R = PolynomialRing(QQ, 'x', n, order='negdeglex')
    elif ORDERING == _sage_const_5 :
        R = PolynomialRing(QQ, 'x', n, order='negdegrevlex')
    elif ORDERING == _sage_const_6 :
        R = PolynomialRing(QQ, 'x', n, order='degneglex')

    rand.seed(int(_sage_const_0 )) # needed to ensure that each ideal is used with each ordering

    t = time.time()
    try:
        with open('data.txt', 'a') as f:
            for _ in range(NUM_IDEALS):
                numpolys = rand.randint(_sage_const_1 ,MAX_IDEAL_SIZE)
            polyarrays = []
            polys = []
            for i in range(numpolys):
                curpol = _sage_const_0 
                curpolarray = []
                numterms = rand.randint(_sage_const_1 ,MAX_POLY_TERMS)
                for j in range(numterms):
                    coef = rand.randint(MIN_COEF, MAX_COEF)
                    deg = [rand.randint(_sage_const_0 ,MAX_DEG) for __ in range(n)]
                    curpolarray.append([coef, deg])
                    term = coef
                    for i in range(n):
                        term *= R.gens()[i]**deg[i]
                    curpol += term
                if curpol != _sage_const_0 : polys.append(curpol)
                polyarrays.append(curpolarray)
            for i in range(_sage_const_5 -numpolys):
                break
            # TODO append array representing zero array to polys
                # can be done post dataset generation

            I = R.ideal(polys)
            result = gb_stopwatch(I, OP_LIMIT)

            for poly in polys:
                print(poly)
            print(polyarrays)
            print(f"{result} polys computed")
            # totaltime += result
            # print(f'run number {i}: The current runtime is {totaltime} seconds.', end=' ')
            # if result == TIME_LIMIT:
            #     print('The previous computation timed out.')
            # else:
            #     print(f'The previous computation took {result} seconds.')
            # print(f'ETA: {totaltime/(i+1) * (NUM_SAMPLES - i)} seconds')

            # to_write = ""
            # for B in A:
            #     for j in B:
            #         to_write += str(j) + " "
            # to_write += str(result)
            # to_write += "\n"
            # f.write(to_write)
    except KeyboardInterrupt:
        return
    print(f"{time.time()-t} seconds elapsed")

def main():
    OP_LIMIT = _sage_const_1000 
    NUM_IDEALS = _sage_const_10 
    MAX_DEG = _sage_const_10 
    MAX_IDEAL_SIZE = _sage_const_5 
    MAX_COEF = _sage_const_10 
    MIN_COEF = -_sage_const_10 
    MAX_POLY_TERMS = _sage_const_10 

    processes = [mp.Process(target=gen_dataset,
                            args=(OP_LIMIT,
                                  NUM_IDEALS,
                                  _,
                                  MAX_IDEAL_SIZE,
                                  MAX_POLY_TERMS,
                                  MIN_COEF,
                                  MAX_COEF,
                                  MAX_DEG)
                            )
                 for _ in range(_sage_const_7 )]
    for p in processes:
        p.start()

if __name__ == "__main__":
    main()

